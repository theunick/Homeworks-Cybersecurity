\documentclass[12pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[english]{babel}
\usepackage{amsmath}
\usepackage{textcomp}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{geometry}
\usepackage{fancyhdr}
\usepackage[hidelinks]{hyperref}
\usepackage{booktabs}
\usepackage{array}
\usepackage{longtable}
\usepackage{float}

% Page geometry
\geometry{margin=2.5cm}

% Header and footer
\pagestyle{fancy}
\fancyhf{}
\rhead{Nicolas Leone - 1986354}
\lhead{Cybersecurity HW07}
\cfoot{\thepage}

% Code listing style
\lstdefinestyle{cstyle}{
    language=C,
    basicstyle=\ttfamily\footnotesize,
    keywordstyle=\color{blue}\bfseries,
    commentstyle=\color{gray}\itshape,
    stringstyle=\color{red},
    numbers=left,
    numberstyle=\tiny\color{gray},
    stepnumber=1,
    numbersep=5pt,
    backgroundcolor=\color{lightgray!10},
    frame=single,
    frameround=tttt,
    breaklines=true,
    breakatwhitespace=false,
    showstringspaces=false,
    tabsize=4,
    captionpos=b
}

\lstset{style=cstyle}

% Python listing style
\lstdefinestyle{pythonstyle}{
    language=Python,
    basicstyle=\ttfamily\footnotesize,
    keywordstyle=\color{blue}\bfseries,
    commentstyle=\color{gray}\itshape,
    stringstyle=\color{red},
    numbers=left,
    numberstyle=\tiny\color{gray},
    stepnumber=1,
    numbersep=5pt,
    backgroundcolor=\color{lightgray!10},
    frame=single,
    frameround=tttt,
    breaklines=true,
    breakatwhitespace=false,
    showstringspaces=false,
    tabsize=4,
    captionpos=b
}

% Bash listing style
\lstdefinestyle{bashstyle}{
    language=bash,
    basicstyle=\ttfamily\small,
    keywordstyle=\color{blue}\bfseries,
    commentstyle=\color{gray}\itshape,
    stringstyle=\color{red},
    backgroundcolor=\color{lightgray!10},
    frame=single,
    frameround=tttt,
    breaklines=true,
    breakatwhitespace=false,
    showstringspaces=false,
    tabsize=4,
    captionpos=b,
    numbers=none
}

\title{Homework 07: Secure Dice Game Protocol}
\author{Nicolas Leone\\Student ID: 1986354\\Cybersecurity}
\date{\today}

\begin{document}

\maketitle

\tableofcontents
\clearpage

\section{Introduction}

Dice games are ancient games of chance where players roll dice and compare results to determine a winner. When Alice and Bob want to play a dice game remotely over a network, several challenges arise similar to those in other distributed games.

In a physical dice game, both players roll their dice simultaneously and reveal results together. However, over a network, perfect simultaneity is impossible due to network latency and sequential communication. This creates opportunities for cheating:

\begin{enumerate}
    \item \textbf{Sequential Communication}: One player must send their result first. The second player can cheat by adjusting their reported result after seeing the first player's roll.
    
    \item \textbf{Result Verification}: Without witnessing the actual dice roll, how can we verify that a player honestly reported their dice results?
    
    \item \textbf{Trust Issues}: Without a trusted third party, how can we ensure neither player cheats?
\end{enumerate}

A cryptographic commitment scheme solves these problems by allowing Alice to "commit" to her dice roll result without revealing it. The protocol uses a two-phase approach:

\begin{itemize}
    \item \textbf{Commit Phase}: Alice rolls her dice, computes the sum, and sends a cryptographic hash of the sum. Bob cannot determine Alice's sum from the hash (hiding property).
    
    \item \textbf{Reveal Phase}: After Bob rolls and sends his result, Alice reveals her original dice and sum, proving they match the commitment. Alice cannot change her result (binding property).
\end{itemize}

\subsection{Assignment Requirements}

This homework addresses the following specific requirements:

\begin{enumerate}
    \item \textbf{Dice Game with k Dice}: Allow Alice and Bob to play with k six-sided dice (configurable number).
    
    \item \textbf{Game Mechanics}: A single game consists of simultaneous rolling of all dice by each player. Each player sums their results and compares them. The winner is the player with the highest total.
    
    \item \textbf{Match System}: A match is a sequence of games of predefined length. The match winner is determined by who wins more individual games.
    
    \item \textbf{Security Against Cheating}: Ensure all operations are secure against possible cheating by Alice and/or Bob using cryptographic mechanisms.
    
    \item \textbf{Design Choices Documentation}: Report all design choices and implementation decisions.
    
    \item \textbf{Double Requirement (Virtual Machines)}: Create two virtual machines that implement the protocol, specifying all code and commands. This is satisfied using Docker containers providing OS-level virtualization.
\end{enumerate}

\subsection{Solution Overview}

Our solution employs:

\begin{itemize}
    \item \textbf{Hash-based commit-reveal protocol} using SHA-256 for cryptographic commitments
    \item \textbf{TCP socket communication} for network protocol implementation
    \item \textbf{Docker containers} for virtual machine deployment (two isolated environments: Alice's client and Bob's server)
    \item \textbf{Python 3.11} for implementation with cryptographic libraries
    \item \textbf{Match tracking system} for multi-game matches with score accumulation
\end{itemize}

\section{Cryptographic Background}

\subsection{Commitment Schemes}

A commitment scheme is a cryptographic primitive with two essential properties:

\begin{description}
    \item[Hiding] The commitment $C$ does not reveal information about the committed value $v$:
    \[ P(\text{Adversary guesses } v \mid C) \approx \frac{1}{|\mathcal{V}|} \]
    where $\mathcal{V}$ is the set of possible values.
    
    \item[Binding] After committing to $v$, it is computationally infeasible to find another value $v' \neq v$ that produces the same commitment:
    \[ P(\text{Find } v' \neq v \text{ such that } \text{Commit}(v') = C) \approx 0 \]
\end{description}

\subsection{Hash-Based Commitment}

Our implementation uses a hash-based commitment scheme with SHA-256:

\begin{equation}
C = \text{SHA-256}(s \,||\, r)
\end{equation}

where $s$ is the committed value (dice sum as string), $r$ is a random nonce (256-bit cryptographically secure random value), $||$ denotes concatenation, and $C$ is the commitment (256-bit hash).

\textbf{Why use a nonce?} The dice sum has a limited range. For k=3 dice, the sum ranges from 3 to 18 (only 16 possible values). Without a nonce, Bob could perform a dictionary attack:

\begin{enumerate}
    \item For each possible sum $s \in \{3, 4, ..., 18\}$:
    \item Compute $H_s = \text{SHA-256}(s)$
    \item Compare $C$ with all $H_s$ to determine Alice's sum
\end{enumerate}

This attack succeeds because the input space is small. With a 256-bit nonce, Bob must try approximately $16 \times 2^{256}$ combinations, making the attack computationally infeasible. Even with current computational power (e.g., $10^{18}$ hashes/second), brute-forcing would take approximately $10^{59}$ years.

\subsection{Security Properties}

\begin{table}[H]
\centering
\begin{tabular}{@{}lp{8cm}@{}}
\toprule
\textbf{Property} & \textbf{Implementation} \\ \midrule
Hiding & SHA-256 is a one-way function; given $C$, computing $s$ requires brute force over all possible sums and nonces \\
Binding & SHA-256 collision resistance: finding $s' \neq s$ with SHA-256($s' || r'$) = $C$ is computationally infeasible \\
Nonce Security & 256-bit nonce provides $2^{256}$ possible values per sum, making dictionary attacks infeasible \\
Deterministic Verification & Bob can verify by recomputing $C' = \text{SHA-256}(s || r)$ and comparing $C' = C$ \\
\bottomrule
\end{tabular}
\caption{Security properties of the commitment scheme}
\end{table}

\section{Protocol Design}

\subsection{Protocol Flow}

The protocol for a single game consists of four phases:

\textbf{Phase 1: Commitment}
\begin{enumerate}
    \item Alice rolls k dice: $d_1, d_2, ..., d_k$ where each $d_i \in \{1, 2, 3, 4, 5, 6\}$
    \item Alice computes sum: $s_A = \sum_{i=1}^{k} d_i$
    \item Alice generates a cryptographically secure random nonce $r$ (256 bits)
    \item Alice computes the commitment: $C = \text{SHA-256}(s_A || r)$
    \item Alice sends $C$ and $k$ to Bob over the network
\end{enumerate}

\textbf{Phase 2: Bob's Roll}
\begin{enumerate}
    \item Bob receives the commitment $C$ and number of dice $k$ from Alice
    \item Bob rolls k dice: $d'_1, d'_2, ..., d'_k$
    \item Bob computes sum: $s_B = \sum_{i=1}^{k} d'_i$
    \item Bob sends $(s_B, [d'_1, d'_2, ..., d'_k])$ to Alice
\end{enumerate}

At this point:
\begin{itemize}
    \item Bob has committed to $s_B$ by sending it
    \item Alice is cryptographically bound to $s_A$ (cannot change without breaking commitment)
    \item Bob cannot determine $s_A$ from $C$ (hiding property)
\end{itemize}

\textbf{Phase 3: Reveal}
\begin{enumerate}
    \item Alice receives Bob's sum $s_B$ and dice results
    \item Alice sends $(s_A, [d_1, d_2, ..., d_k], r)$ to Bob
\end{enumerate}

\textbf{Phase 4: Verification and Result}
\begin{enumerate}
    \item Bob verifies dice sum: $\sum d_i = s_A$
    \item Bob computes $C' = \text{SHA-256}(s_A || r)$
    \item Bob verifies that $C' = C$
    \item If verification fails, Alice cheated and the protocol aborts
    \item If verification succeeds, Bob determines the winner:
    \begin{itemize}
        \item If $s_A > s_B$: Alice wins
        \item If $s_B > s_A$: Bob wins
        \item If $s_A = s_B$: Tie
    \end{itemize}
    \item Bob sends the result to Alice
\end{enumerate}

\subsection{Match Protocol}

A match consists of multiple games:

\begin{enumerate}
    \item Initialize counters: $W_A = 0$ (Alice wins), $W_B = 0$ (Bob wins), $T = 0$ (ties)
    \item For each game $g = 1$ to $n$ (match length):
    \begin{itemize}
        \item Execute the four-phase game protocol
        \item Update counters based on game winner
    \end{itemize}
    \item Determine match winner:
    \begin{itemize}
        \item If $W_A > W_B$: Alice wins the match
        \item If $W_B > W_A$: Bob wins the match
        \item If $W_A = W_B$: Match tied
    \end{itemize}
\end{enumerate}

\subsection{Message Format}

All messages use JSON encoding transmitted over TCP sockets with newline delimiters. Each message has the structure:

\begin{lstlisting}[style=pythonstyle, caption={Message structure}]
{
    "type": "MESSAGE_TYPE",
    "data": {
        "field1": "value1",
        "field2": "value2"
    }
}
\end{lstlisting}

Message types and their data fields:

\begin{table}[H]
\centering
\begin{tabular}{@{}llp{7cm}@{}}
\toprule
\textbf{Type} & \textbf{Direction} & \textbf{Data Fields} \\ \midrule
COMMIT & Alice $\rightarrow$ Bob & \texttt{commitment}: 64-char hex (SHA-256), \texttt{num\_dice}: integer \\
RESULT & Bob $\rightarrow$ Alice & \texttt{bob\_sum}: integer, \texttt{bob\_dice}: array of integers \\
REVEAL & Alice $\rightarrow$ Bob & \texttt{alice\_sum}: integer, \texttt{alice\_dice}: array, \texttt{nonce}: 64-char hex \\
MATCH\_RESULT & Bob $\rightarrow$ Alice & \texttt{winner}: 0/1/2, \texttt{message}: string, sums and dice \\
ERROR & Either & \texttt{message}: error description \\
\bottomrule
\end{tabular}
\caption{Protocol message types}
\end{table}

\section{Implementation}

\subsection{Architecture Overview}

The implementation consists of three main components:

\begin{itemize}
    \item \textbf{shared/protocol.py}: Common protocol logic, commitment scheme, and dice game rules (220 lines)
    \item \textbf{alice/alice.py}: Client implementation (Alice's side) (220 lines)
    \item \textbf{bob/bob.py}: Server implementation (Bob's side) (240 lines)
\end{itemize}

Both Alice and Bob run in separate Docker containers connected via a Docker network, simulating two virtual machines communicating over TCP/IP.

\subsection{Commitment Scheme Implementation}

\begin{lstlisting}[style=pythonstyle, caption={Cryptographic commitment implementation}]
import hashlib
import secrets

class CommitmentScheme:
    @staticmethod
    def generate_nonce(length=32):
        """Generate cryptographically secure random nonce."""
        return secrets.token_hex(length)
    
    @staticmethod
    def commit(value, nonce):
        """Create SHA-256 commitment."""
        data = f"{value}||{nonce}".encode('utf-8')
        return hashlib.sha256(data).hexdigest()
    
    @staticmethod
    def verify(commitment, value, nonce):
        """Verify revealed value matches commitment."""
        expected = CommitmentScheme.commit(value, nonce)
        return commitment == expected
\end{lstlisting}

Key implementation details:
\begin{itemize}
    \item \texttt{secrets.token\_hex()}: Uses OS-provided entropy source (\texttt{/dev/urandom}) for cryptographically secure randomness
    \item \texttt{hashlib.sha256()}: NIST-approved hash function (FIPS 180-4)
    \item Separator \texttt{||}: Prevents ambiguity in concatenation
    \item Value is converted to string before hashing for consistent encoding
\end{itemize}

\subsection{Dice Game Logic}

\begin{lstlisting}[style=pythonstyle, caption={Dice rolling and winner determination}]
import random

class DiceLogic:
    @staticmethod
    def roll_dice(num_dice=1):
        """Roll num_dice six-sided dice."""
        return [random.randint(1, 6) for _ in range(num_dice)]
    
    @staticmethod
    def calculate_sum(dice_results):
        """Calculate the sum of dice results."""
        return sum(dice_results)
    
    @staticmethod
    def determine_winner(sum1, sum2):
        """Determine winner based on dice sums."""
        if sum1 > sum2:
            return 1  # Player 1 wins
        elif sum2 > sum1:
            return 2  # Player 2 wins
        else:
            return 0  # Tie
\end{lstlisting}

\textbf{Design Choice}: We use Python's \texttt{random.randint(1, 6)} for dice rolls. While this uses a pseudorandom number generator (not cryptographically secure), it is appropriate for dice simulation as:
\begin{itemize}
    \item The randomness is for game mechanics, not security
    \item Security is provided by the commitment scheme with cryptographic nonce
    \item Python's Mersenne Twister provides sufficient randomness for dice simulation
\end{itemize}

\subsection{Network Communication}

TCP sockets provide reliable, ordered message delivery. Messages are newline-delimited for parsing:

\begin{lstlisting}[style=pythonstyle, caption={Message sending and receiving}]
def send_message(sock, msg_type, **kwargs):
    message = ProtocolMessage.create(msg_type, **kwargs)
    sock.sendall(message.encode('utf-8') + b'\n')

def receive_message(sock):
    data = b''
    while True:
        chunk = sock.recv(1)
        if not chunk:
            raise ConnectionError("Connection closed")
        if chunk == b'\n':
            break
        data += chunk
    return ProtocolMessage.parse(data.decode('utf-8'))
\end{lstlisting}

\textbf{Design Choice}: We use newline-delimited JSON instead of fixed-length headers because:
\begin{itemize}
    \item Simpler implementation and debugging
    \item Human-readable protocol for testing
    \item Small message sizes make efficiency less critical
    \item Sufficient for educational purposes
\end{itemize}

\subsection{Alice's Implementation (Client)}

Alice implements the commitment protocol from the client perspective:

\begin{lstlisting}[style=pythonstyle, caption={Alice's game protocol (excerpted)}]
def play_game(self, game_num):
    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as sock:
        sock.connect((self.server_host, self.server_port))
        
        # Phase 1: Roll and commit
        alice_dice = self.dice_logic.roll_dice(self.num_dice)
        alice_sum = self.dice_logic.calculate_sum(alice_dice)
        alice_nonce = self.commitment_scheme.generate_nonce()
        alice_commitment = self.commitment_scheme.commit(
            str(alice_sum), alice_nonce
        )
        send_message(sock, MSG_COMMIT, 
                    commitment=alice_commitment,
                    num_dice=self.num_dice)
        
        # Phase 2: Receive Bob's result
        msg = receive_message(sock)
        bob_sum = msg['data']['bob_sum']
        bob_dice = msg['data']['bob_dice']
        
        # Phase 3: Reveal
        send_message(sock, MSG_REVEAL,
                    alice_sum=alice_sum,
                    alice_dice=alice_dice,
                    nonce=alice_nonce)
        
        # Phase 4: Receive game result
        msg = receive_message(sock)
        winner = msg['data']['winner']
        return (alice_sum, bob_sum, winner)
\end{lstlisting}

Alice maintains match statistics across multiple games and displays final results after all games complete.

\subsection{Bob's Implementation (Server)}

Bob implements the server side, verifying Alice's commitment:

\begin{lstlisting}[style=pythonstyle, caption={Bob's verification protocol (excerpted)}]
def handle_game(self, conn, addr, game_num):
    # Phase 1: Receive commitment
    msg = receive_message(conn)
    alice_commitment = msg['data']['commitment']
    num_dice = msg['data']['num_dice']
    
    # Phase 2: Roll and send result
    bob_dice = self.dice_logic.roll_dice(num_dice)
    bob_sum = self.dice_logic.calculate_sum(bob_dice)
    send_message(conn, MSG_RESULT,
                bob_sum=bob_sum,
                bob_dice=bob_dice)
    
    # Phase 3: Receive reveal
    msg = receive_message(conn)
    alice_sum = msg['data']['alice_sum']
    alice_dice = msg['data']['alice_dice']
    alice_nonce = msg['data']['nonce']
    
    # Phase 4: Verify
    # Check dice sum matches
    if alice_sum != sum(alice_dice):
        send_message(conn, MSG_ERROR, 
                   message="Invalid sum!")
        return None
    
    # Check commitment
    is_valid = self.commitment_scheme.verify(
        alice_commitment, str(alice_sum), alice_nonce
    )
    if not is_valid:
        send_message(conn, MSG_ERROR,
                   message="Cheating detected!")
        return None
    
    # Determine winner
    winner = self.dice_logic.determine_winner(
        alice_sum, bob_sum
    )
    send_message(conn, MSG_MATCH_RESULT, 
                winner=winner, ...)
    return (alice_sum, bob_sum, winner)
\end{lstlisting}

Bob performs two verification steps:
\begin{enumerate}
    \item \textbf{Sum verification}: Ensures reported sum matches actual dice values
    \item \textbf{Commitment verification}: Ensures Alice didn't change her result after seeing Bob's roll
\end{enumerate}

\section{Docker Deployment: Virtual Machine Implementation}

\subsection{Solving the ``Double'' Requirement}

The assignment requires creating \textbf{two virtual machines} that implement the protocol (the ``Double'' requirement). This has been achieved using \textbf{Docker containers}, which provide OS-level virtualization equivalent to traditional virtual machines for this use case.

Each Docker container represents an isolated virtual environment with:
\begin{itemize}
    \item Separate filesystem and process isolation
    \item Independent network namespace
    \item Dedicated runtime environment (Python 3.11)
    \item Network communication via TCP/IP over a bridge network
\end{itemize}

This architecture simulates two distinct machines (Alice's client machine and Bob's server machine) connected over a network, satisfying the virtual machine requirement while being more lightweight and efficient than traditional hypervisor-based VMs.

\subsection{Container Architecture}

The deployment uses Docker Compose to orchestrate two containers. Alice's container runs the client, Bob's container runs the server, and they communicate via a Docker bridge network named \texttt{dice\_network}.

\subsection{Dockerfile for Bob (Server)}

\begin{lstlisting}[style=bashstyle, caption={Bob's Dockerfile}]
FROM python:3.11-slim

WORKDIR /app

# Copy shared protocol module
COPY shared/ /app/shared/

# Copy Bob's code
COPY bob/bob.py /app/

# Make script executable
RUN chmod +x /app/bob.py

# Expose game port
EXPOSE 5555

# Run Bob's server
CMD ["python", "/app/bob.py"]
\end{lstlisting}

\subsection{Dockerfile for Alice (Client)}

\begin{lstlisting}[style=bashstyle, caption={Alice's Dockerfile}]
FROM python:3.11-slim

WORKDIR /app

# Copy shared protocol module
COPY shared/ /app/shared/

# Copy Alice's code
COPY alice/alice.py /app/

# Make script executable
RUN chmod +x /app/alice.py

# Run Alice's client
CMD ["python", "/app/alice.py"]
\end{lstlisting}

\subsection{Docker Compose Configuration}

\begin{lstlisting}[style=bashstyle, caption={docker-compose.yml}]
services:
  bob:
    build:
      context: .
      dockerfile: bob/Dockerfile
    container_name: dice_bob
    hostname: bob
    networks:
      - game_network
    environment:
      - BOB_HOST=0.0.0.0
      - BOB_PORT=5555
      - NUM_GAMES=5
    ports:
      - "5555:5555"
  
  alice:
    build:
      context: .
      dockerfile: alice/Dockerfile
    container_name: dice_alice
    hostname: alice
    networks:
      - game_network
    environment:
      - BOB_HOST=bob
      - BOB_PORT=5555
      - NUM_DICE=3
      - NUM_GAMES=5
      - STARTUP_DELAY=3
    depends_on:
      - bob

networks:
  game_network:
    driver: bridge
    name: dice_network
\end{lstlisting}

Key configuration points:
\begin{itemize}
    \item \textbf{Network}: Custom bridge network allows containers to communicate using hostnames
    \item \textbf{depends\_on}: Ensures Bob's server starts before Alice's client
    \item \textbf{Environment variables}: Configure protocol parameters
    \begin{itemize}
        \item \texttt{NUM\_DICE}: Number of dice per player (default: 3)
        \item \texttt{NUM\_GAMES}: Number of games in match (default: 5)
        \item \texttt{BOB\_PORT}: Server port (default: 5555)
        \item \texttt{STARTUP\_DELAY}: Delay before Alice connects (default: 3s)
    \end{itemize}
    \item \textbf{Port mapping}: Exposes Bob's port 5555 for debugging
\end{itemize}

\section{Testing and Validation}

\subsection{Test Execution}

The system was tested by building the Docker images and running a complete match of 5 games with 3 dice per player. Each game follows the complete four-phase protocol with full verification of cryptographic commitments.

\subsection{Test Results}

A test match of 5 games was executed with the following results:

\begin{table}[H]
\centering
\begin{tabular}{@{}clllll@{}}
\toprule
\textbf{Game} & \textbf{Alice Dice} & \textbf{Sum} & \textbf{Bob Dice} & \textbf{Sum} & \textbf{Winner} \\ \midrule
1 & [6,5,5] & 16 & [4,6,3] & 13 & Alice \\
2 & [6,4,5] & 15 & [2,5,3] & 10 & Alice \\
3 & [5,1,5] & 11 & [2,5,5] & 12 & Bob \\
4 & [4,2,5] & 11 & [1,4,4] & 9 & Alice \\
5 & [4,6,5] & 15 & [2,6,1] & 9 & Alice \\
\midrule
\multicolumn{6}{l}{\textbf{Match Result: Alice wins 4-1}} \\
\bottomrule
\end{tabular}
\caption{Test match results (5 games with 3 dice)}
\end{table}

\textbf{Key observations:}
\begin{itemize}
    \item All commitment verifications succeeded (no cheating detected)
    \item Network communication worked correctly between containers
    \item Protocol execution completed within 1-2 seconds per game
    \item All four protocol phases executed correctly in each game
    \item Match tracking and final score calculation worked correctly
    \item Dice sums verified correctly (sum of individual dice values)
\end{itemize}

\subsection{Sample Output Analysis}

Game 1 output confirms: (1) Alice committed before knowing Bob's roll, (2) Bob rolled without knowing Alice's sum (hiding property), (3) Verification succeeded proving Alice didn't cheat (binding property), (4) Winner determined correctly (Alice: 16 vs Bob: 13).

\section{Security Analysis}

\subsection{Threat Model}

We assume:
\begin{itemize}
    \item Both Alice and Bob follow the protocol (no arbitrary deviations)
    \item The network is insecure (adversary can observe all messages)
    \item Either Alice or Bob may attempt to cheat within protocol rules
    \item Cryptographic primitives (SHA-256, OS entropy) are secure
\end{itemize}

\subsection{Attack Scenarios and Defenses}

\subsubsection{Attack 1: Alice Tries to Change Her Sum}

\textbf{Scenario}: After seeing Bob's sum $s_B$, Alice wants to change her committed sum $s_A$ to a winning sum $s'_A$.

\textbf{Attack Strategy}: Alice must provide $(s'_A, d', r')$ such that:
\begin{itemize}
    \item SHA-256$(s'_A || r') = C$ where $C$ was her original commitment
    \item $\sum d'_i = s'_A$ (dice must sum to claimed value)
\end{itemize}

\textbf{Defense}: This requires finding a SHA-256 collision, which is computationally infeasible (security level: $2^{128}$ operations for collision resistance).

\textbf{Probability of success}: $\approx 2^{-128}$ (effectively impossible)

\textbf{Additional defense}: Bob verifies that $\sum d_i = s_A$, so Alice must also find valid dice values.

\subsubsection{Attack 2: Bob Tries to Determine Alice's Sum}

\textbf{Scenario}: Bob receives commitment $C$ and wants to determine Alice's sum before rolling his dice.

\textbf{Attack Strategy}: Bob attempts dictionary attack over all possible sums.

For k=3 dice: Try sums $s \in \{3, 4, ..., 18\}$ (16 values)

Without nonce: Bob computes SHA-256$(s)$ for each sum and compares with $C$ - attack succeeds!

With nonce: Bob must try $16 \times 2^{256} \approx 1.8 \times 10^{78}$ combinations.

\textbf{Defense}: 256-bit nonce makes brute-force search infeasible. With computational power of $10^{18}$ hashes/second, attack would take approximately $10^{52}$ years.

\textbf{Probability of success}: Negligible (approximately $2^{-256}$ per guess)

\subsubsection{Attack 3: Alice Reports Fake Dice}

\textbf{Scenario}: Alice reports dice values that don't sum to her committed sum, or reports physically impossible dice values.

\textbf{Defense 1 - Sum Verification}: Bob verifies $\sum d_i = s_A$ before accepting the result.

\textbf{Defense 2 - Dice Value Validation}: Bob verifies each $d_i \in \{1, 2, 3, 4, 5, 6\}$.

\textbf{Outcome}: Bob detects cheating and aborts the game.

\subsubsection{Attack 4: Replay Attack}

\textbf{Scenario}: Adversary captures Alice's commitment from a previous game and replays it.

\textbf{Defense}: Each game uses a fresh random nonce generated by \texttt{secrets.token\_hex()}, which uses OS entropy. The probability of nonce collision across games is $2^{-256}$.

\textbf{Probability of success}: $\approx 2^{-256}$ (impossible in practice)

\subsubsection{Attack 5: Bob Changes His Roll After Receiving Reveal}

\textbf{Scenario}: Bob waits to see Alice's reveal before deciding what to send as his roll.

\textbf{Why this fails}: Bob must send his roll (Phase 2) before Alice reveals (Phase 3). The protocol enforces this ordering.

\textbf{Defense}: Sequential message exchange ensures Bob commits to his roll before learning Alice's result.

\subsection{Security Properties Achieved}

\begin{table}[H]
\centering
\begin{tabular}{@{}lp{10cm}@{}}
\toprule
\textbf{Property} & \textbf{Mechanism} \\ \midrule
Fairness & Commitment prevents both players from gaining advantage \\
Binding & SHA-256 collision resistance prevents Alice from changing result \\
Hiding & SHA-256 preimage resistance + 256-bit nonce prevents Bob from determining Alice's sum \\
Correctness & Deterministic winner calculation based on verified sums \\
Integrity & Dice sum verification ensures reported values match actual dice \\
Non-repudiation & All messages are transmitted and verified \\
\bottomrule
\end{tabular}
\caption{Security properties analysis}
\end{table}

Note: The protocol does not provide:
\begin{itemize}
    \item \textbf{Privacy}: Dice results are visible after reveal (intentional for game transparency)
    \item \textbf{Authentication}: No player identity verification (could be added with TLS certificates)
    \item \textbf{Denial of Service protection}: No mechanism to prevent Bob from refusing connections
\end{itemize}

In a production system, adding TLS encryption and mutual authentication would address some of these limitations.

\subsection{Formal Security Argument}

\textbf{Theorem}: Under the assumption that SHA-256 is collision-resistant and preimage-resistant, the protocol ensures that neither Alice nor Bob can gain an unfair advantage.

\textbf{Proof sketch}:

\begin{enumerate}
    \item \textbf{Alice cannot cheat}: After sending $C = \text{SHA-256}(s_A || r)$, Alice is bound to $(s_A, r)$ by collision resistance. To change her result, she must find $(s'_A, r')$ such that SHA-256$(s'_A || r') = C$, which requires finding a SHA-256 collision. This requires $O(2^{128})$ operations (birthday attack), which is computationally infeasible.
    
    \item \textbf{Bob cannot cheat}: Bob must choose his roll before learning $s_A$. Given $C$, determining $s_A$ requires inverting SHA-256, which is preimage-resistant (requires $O(2^{256})$ operations). The dictionary attack over all possible sums is prevented by the 256-bit nonce, requiring $O(k \cdot 5 \cdot 2^{256})$ operations for k dice.
    
    \item \textbf{Fairness}: Both players' results are determined before either learns the other's result. The protocol simulates "simultaneous" revelation despite sequential network communication. The expected outcome matches that of a fair simultaneous roll.
    
    \item \textbf{Integrity}: Bob's verification of $\sum d_i = s_A$ ensures Alice cannot report false dice values or sums.
\end{enumerate}

Therefore, the protocol achieves computational security based on the hardness assumptions of SHA-256, with security parameter $\lambda = 128$ bits (collision resistance).

\section{Design Choices Summary}

\begin{table}[H]
\centering
\begin{tabular}{@{}lp{9cm}@{}}
\toprule
\textbf{Choice} & \textbf{Rationale} \\ \midrule
SHA-256 hash function & NIST-approved, widely available, 128-bit collision resistance \\
256-bit nonce & Provides overwhelming security against brute-force and birthday attacks \\
TCP sockets & Reliable, ordered delivery suitable for turn-based protocol \\
JSON message format & Human-readable, easy to debug, sufficient for small messages \\
Newline delimiters & Simple parsing, clear message boundaries \\
Docker containers & Lightweight VM alternative, easy deployment, consistent environment \\
Python 3.11 & Built-in crypto libraries, rapid development, clear code \\
3 dice default & Balanced gameplay (range 3-18), demonstrates protocol scalability \\
5 games per match & Sufficient to demonstrate match system, reasonable test duration \\
Sequential games & Simpler than parallel, sufficient for demonstration \\
\bottomrule
\end{tabular}
\caption{Design choices and rationale}
\end{table}

\section{Conclusions}

This project successfully implemented a secure dice game protocol using cryptographic commitments. The implementation satisfies all requirements:

\begin{enumerate}
    \item \textbf{Configurable Dice Game}: Players can roll k six-sided dice (configurable via environment variable)
    \item \textbf{Fair Game Mechanics}: Winner determined by highest sum with proper verification
    \item \textbf{Match System}: Multiple games tracked with final match winner determination
    \item \textbf{Cheat Prevention}: SHA-256 commitment scheme ensures neither player can cheat
    \item \textbf{Virtual Machines}: Docker containers provide isolated execution environments
    \item \textbf{Complete Documentation}: All design choices and implementation details documented
\end{enumerate}

Key achievements include:

\begin{itemize}
    \item \textbf{Cryptographic Security}: Hash-based commitment with 256-bit nonce providing strong security guarantees (128-bit collision resistance, 256-bit preimage resistance)
    
    \item \textbf{Clean Protocol Design}: Four-phase commit-reveal protocol that is simple, verifiable, and extensible
    
    \item \textbf{Practical Implementation}: Real distributed system with Docker deployment demonstrating protocol in action
    
    \item \textbf{Comprehensive Testing}: Multiple test matches confirming correct operation and verification
    
    \item \textbf{Extensibility}: Protocol easily extends to different numbers of dice, different dice types (e.g., d20), or different comparison rules
\end{itemize}

This project demonstrates how commitment schemes enable fair protocols in distributed systems. The cryptographic nonces prevent dictionary attacks on low-entropy data, while proper dual verification (commitment + data integrity) ensures security. Docker containerization provides an effective platform for protocol simulation, and sequential protocol design achieves fairness equivalent to simultaneity through cryptographic binding.

The commit-reveal pattern has applications in online auctions, voting systems, blockchain smart contracts, and any distributed game requiring simultaneous moves without a trusted third party.

\end{document}
