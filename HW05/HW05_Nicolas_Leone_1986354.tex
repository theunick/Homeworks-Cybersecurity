\documentclass[12pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[english]{babel}
\usepackage{amsmath}
\usepackage{textcomp}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{geometry}
\usepackage{fancyhdr}
\usepackage[hidelinks]{hyperref}
\usepackage{booktabs}
\usepackage{array}
\usepackage{longtable}
\usepackage{float}

% Page geometry
\geometry{margin=2.5cm}

% Header and footer
\pagestyle{fancy}
\fancyhf{}
\rhead{Nicolas Leone - 1986354}
\lhead{Cybersecurity HW05}
\cfoot{\thepage}

% Code listing style
\lstdefinestyle{cstyle}{
    language=C,
    basicstyle=\ttfamily\footnotesize,
    keywordstyle=\color{blue}\bfseries,
    commentstyle=\color{gray}\itshape,
    stringstyle=\color{red},
    numbers=left,
    numberstyle=\tiny\color{gray},
    stepnumber=1,
    numbersep=5pt,
    backgroundcolor=\color{lightgray!10},
    frame=single,
    frameround=tttt,
    breaklines=true,
    breakatwhitespace=false,
    showstringspaces=false,
    tabsize=4,
    captionpos=b
}

\lstset{style=cstyle}

% Python listing style
\lstdefinestyle{pythonstyle}{
    language=Python,
    basicstyle=\ttfamily\footnotesize,
    keywordstyle=\color{blue}\bfseries,
    commentstyle=\color{gray}\itshape,
    stringstyle=\color{red},
    numbers=left,
    numberstyle=\tiny\color{gray},
    stepnumber=1,
    numbersep=5pt,
    backgroundcolor=\color{lightgray!10},
    frame=single,
    frameround=tttt,
    breaklines=true,
    breakatwhitespace=false,
    showstringspaces=false,
    tabsize=4,
    captionpos=b
}

% Bash listing style
\lstdefinestyle{bashstyle}{
    language=bash,
    basicstyle=\ttfamily\small,
    keywordstyle=\color{blue}\bfseries,
    commentstyle=\color{gray}\itshape,
    stringstyle=\color{red},
    backgroundcolor=\color{lightgray!10},
    frame=single,
    frameround=tttt,
    breaklines=true,
    breakatwhitespace=false,
    showstringspaces=false,
    tabsize=4,
    captionpos=b,
    numbers=none
}

\title{Homework 05: Secure Pseudo-Random Number Generators}
\author{Nicolas Leone\\Student ID: 1986354\\Cybersecurity}
\date{\today}

\begin{document}

\maketitle

\tableofcontents
\clearpage

\section{Introduction}

Random number generation is a fundamental component of modern cryptography, essential for key generation, initialization vectors, nonces, and various other security-critical applications. A Cryptographically Secure Pseudo-Random Number Generator (CS-PRNG), also known as a Deterministic Random Bit Generator (DRBG), is a deterministic algorithm that produces sequences of bits that are computationally indistinguishable from true random sequences.

\subsection{Objectives}

This homework focuses on implementing and comparing different DRBG constructions. The main objectives are:

\begin{itemize}
    \item Implement three different CS-PRNG algorithms for generating binary strings
    \item Compare their performance in terms of:
    \begin{itemize}
        \item Execution time
        \item Memory consumption (space complexity)
        \item Statistical distribution of generated bits (ratio of 0s and 1s)
    \end{itemize}
    \item Analyze sequences of varying lengths from $10^4$ to $10^7$ bits
    \item Visualize results through charts and graphs
\end{itemize}

\subsection{Security Requirements for CS-PRNGs}

A cryptographically secure pseudo-random number generator must satisfy the following properties:

\begin{enumerate}
    \item \textbf{Unpredictability}: Given $n$ bits of output, it should be computationally infeasible to predict the $(n+1)$-th bit with probability significantly better than 50\%
    \item \textbf{Indistinguishability}: The output should be computationally indistinguishable from a truly random sequence by any polynomial-time algorithm
    \item \textbf{Forward Secrecy}: Compromise of the internal state at time $t$ should not allow reconstruction of previous outputs
    \item \textbf{Backtracking Resistance}: Knowledge of past internal states should not help predict future outputs if the generator is properly reseeded
\end{enumerate}

\newpage

\section{DRBG Implementations}

\subsection{ChaCha20-based DRBG}

ChaCha20 is a stream cipher designed by Daniel J. Bernstein, known for its high performance in software implementations without requiring hardware acceleration.

\textbf{Design Parameters:}
\begin{itemize}
    \item 256-bit key + 96-bit nonce (352-bit seed)
    \item 512-bit internal state ($4 \times 4$ matrix of 32-bit words)
    \item 32-bit block counter, incremented per 512-bit block
    \item 20 rounds of quarter-round operations
\end{itemize}

The implementation uses Python's \texttt{cryptography} library for optimized ChaCha20 operations. Random bits are generated by encrypting a zero-filled buffer, converting the resulting bytes to a binary string.

\subsection{AES-CTR based DRBG}

AES in Counter Mode is a NIST-standardized construction (SP 800-90A) that benefits from hardware acceleration (AES-NI) on modern processors.

\textbf{Design Parameters:}
\begin{itemize}
    \item 256-bit AES key
    \item 128-bit counter value
    \item 128 bits per encryption operation
    \item Deterministic counter-based generation
\end{itemize}

The generator encrypts sequential counter values using AES-256, producing 16 bytes per block. This approach provides well-studied security properties and excellent performance on supported hardware.

\subsection{HMAC-DRBG}

HMAC-DRBG is a hash-based construction specified in NIST SP 800-90A, using HMAC with SHA-256.

\textbf{Design Parameters:}
\begin{itemize}
    \item Two 256-bit values: Key (K) and Value (V)
    \item Update function: $V = \text{HMAC}_K(V)$
    \item Output derived from sequential HMAC operations
    \item Explicit state update mechanism
\end{itemize}

This implementation follows the NIST specification precisely, providing good security without requiring block ciphers. The trade-off is higher computational cost due to multiple hash evaluations per output block.

\section{Results and Analysis}

\subsection{Performance Comparison}

The benchmark results provide insights into the trade-offs between the three DRBG implementations across different sequence lengths.

\subsubsection{Execution Time}

\begin{figure}[H]
\centering
\includegraphics[width=0.85\textwidth]{time_comparison.png}
\caption{Execution time comparison across different sequence lengths}
\label{fig:time}
\end{figure}

\textbf{Key Observations:}
\begin{itemize}
    \item \textbf{ChaCha20-DRBG} and \textbf{AES-CTR DRBG} show similar performance, with average generation times of 0.0313s and 0.0322s respectively
    \item \textbf{HMAC-DRBG} is significantly slower (0.1209s average), approximately 4× slower than cipher-based approaches
    \item All implementations scale linearly with sequence length, as expected for streaming operations
    \item For the largest sequence ($10^7$ bits), ChaCha20 completed in 0.112s, AES-CTR in 0.114s, and HMAC-DRBG in 0.461s
\end{itemize}

The performance difference is primarily due to the number of cryptographic operations required:
\begin{itemize}
    \item ChaCha20 and AES-CTR encrypt data in single-pass operations
    \item HMAC-DRBG requires multiple hash function evaluations per output block (32 bytes), resulting in higher computational overhead
\end{itemize}

\subsubsection{Memory Consumption}

\begin{figure}[H]
\centering
\includegraphics[width=0.85\textwidth]{memory_comparison.png}
\caption{Memory usage comparison across different sequence lengths}
\label{fig:memory}
\end{figure}

\textbf{Key Observations:}
\begin{itemize}
    \item Memory consumption is nearly identical across all implementations, averaging around 22 MB
    \item Memory scales linearly with output size, as the binary string representation dominates memory usage
    \item For $10^7$ bits (1.25 MB of binary data), peak memory reaches approximately 80 MB due to Python string overhead
    \item The slight advantage of HMAC-DRBG (22.03 MB average vs 22.36 MB) is negligible in practice
\end{itemize}

The memory footprint is primarily determined by the output string representation rather than the DRBG algorithm itself. In production implementations, streaming or chunked output would reduce memory requirements significantly.

\subsubsection{Statistical Distribution}

\begin{figure}[H]
\centering
\includegraphics[width=\textwidth]{distribution_comparison.png}
\caption{Distribution of 0s and 1s in generated sequences}
\label{fig:distribution}
\end{figure}

\textbf{Key Observations:}
\begin{itemize}
    \item All three implementations produce well-balanced outputs, with deviations from 50\% within expected statistical bounds
    \item For $10^4$ bits, maximum deviation is 0.58\% (ChaCha20), well within the $\pm 1\%$ tolerance
    \item As sequence length increases, the distribution converges closer to the theoretical 50/50 ratio
    \item At $10^7$ bits, all implementations show deviations less than 0.02\%, demonstrating excellent randomness
\end{itemize}

The statistical uniformity confirms that all implementations meet the basic requirement of unbiased bit generation. More rigorous testing (e.g., NIST Statistical Test Suite) would provide deeper insights into randomness quality.

\subsubsection{Combined Performance}

\begin{figure}[H]
\centering
\includegraphics[width=0.85\textwidth]{combined_performance.png}
\caption{Normalized combined performance score (lower is better)}
\label{fig:combined}
\end{figure}

This chart combines time and memory metrics into a single normalized score. Since memory usage is nearly identical across implementations, the performance differences are primarily driven by execution time, clearly showing the advantage of cipher-based DRBGs over hash-based construction.

\subsection{Detailed Metrics Summary}

\input{summary_table.tex}

Table \ref{tab:summary} presents the average performance metrics across all tested sequence lengths. The results clearly demonstrate:

\begin{enumerate}
    \item \textbf{Speed Ranking}: AES-CTR $\approx$ ChaCha20 $>>$ HMAC-DRBG
    \item \textbf{Memory Efficiency}: All implementations are comparable
    \item \textbf{Statistical Quality}: All implementations pass basic uniformity tests
\end{enumerate}

\subsection{Performance Analysis by Sequence Length}

\begin{table}[H]
\centering
\small
\begin{tabular}{@{}lcccc@{}}
\toprule
\textbf{Length} & \textbf{ChaCha20 (s)} & \textbf{AES-CTR (s)} & \textbf{HMAC (s)} & \textbf{Best} \\ \midrule
$10^4$ & 0.0008 & \textbf{0.0001} & 0.0002 & AES-CTR \\
$10^5$ & 0.0011 & 0.0011 & 0.0014 & Tie \\
$10^6$ & \textbf{0.0111} & 0.0137 & 0.0212 & ChaCha20 \\
$10^7$ & \textbf{0.1123} & 0.1139 & 0.4607 & ChaCha20 \\
\bottomrule
\end{tabular}
\caption{Execution time breakdown by sequence length}
\label{tab:detail}
\end{table}

Interesting patterns emerge when examining performance by sequence length:
\begin{itemize}
    \item For small sequences ($10^4$ bits), AES-CTR has an initialization advantage
    \item For medium to large sequences, ChaCha20 gains a slight edge
    \item HMAC-DRBG consistently lags due to its computational complexity
\end{itemize}

\newpage

\section{Security Considerations}

\subsection{Seed Quality and Entropy}

All implementations rely on \texttt{os.urandom()} for initial seeding, which provides cryptographically secure random data from the operating system's entropy pool (\texttt{/dev/urandom} on Unix-like systems). This is critical because:

\begin{itemize}
    \item The security of any DRBG is bounded by the entropy of its seed
    \item Weak or predictable seeds completely compromise the generator's security
    \item \texttt{os.urandom()} is considered suitable for cryptographic use in Python
\end{itemize}

\subsection{State Compromise and Forward Security}

If an attacker gains access to the internal state:

\begin{itemize}
    \item \textbf{ChaCha20-DRBG}: Future outputs become predictable; past outputs remain secure if counter hasn't wrapped
    \item \textbf{AES-CTR DRBG}: Similar to ChaCha20, with predictability depending on counter management
    \item \textbf{HMAC-DRBG}: Includes explicit state update mechanisms (the \texttt{\_update()} function) providing stronger forward security properties
\end{itemize}

\subsection{Reseeding Requirements}

For long-running applications generating large amounts of random data:

\begin{itemize}
    \item NIST recommends reseeding after generating $2^{48}$ bits or periodically (e.g., every hour)
    \item Reseeding involves mixing fresh entropy into the internal state
    \item None of the implementations in this study include automatic reseeding
    \item Production use should implement periodic reseeding from \texttt{os.urandom()}
\end{itemize}

\subsection{Implementation Security Notes}

\begin{itemize}
    \item All implementations use constant-time cryptographic primitives from the \texttt{cryptography} library
    \item No branching based on secret data that could leak information via timing attacks
    \item Counter overflow is not handled (would require wrapping after $2^{32}$ or $2^{128}$ blocks)
    \item No side-channel protection beyond what the underlying libraries provide
\end{itemize}

\newpage

\section{Conclusions}

This study implemented and compared three cryptographically secure pseudo-random number generators based on different cryptographic primitives: ChaCha20 (stream cipher), AES-CTR (block cipher), and HMAC (hash function).

\subsection{Key Findings}

\begin{enumerate}
    \item \textbf{Performance}: ChaCha20-DRBG and AES-CTR DRBG demonstrate comparable performance (0.031-0.032s average), significantly outperforming HMAC-DRBG (0.121s average) by a factor of approximately 4×
    
    \item \textbf{Scalability}: All implementations scale linearly with output size, with ChaCha20 showing slight advantages for large sequences ($>10^6$ bits)
    
    \item \textbf{Memory Efficiency}: Memory consumption is dominated by output string representation (~22 MB average), with negligible differences between implementations
    
    \item \textbf{Statistical Quality}: All three DRBGs produce statistically uniform output:
    \begin{itemize}
        \item Deviations from 50/50 bit distribution are within expected bounds
        \item Larger sequences converge closer to theoretical uniformity
        \item Maximum observed deviation: 0.58\% at $10^4$ bits, decreasing to 0.02\% at $10^7$ bits
    \end{itemize}
    
    \item \textbf{Trade-offs}:
    \begin{itemize}
        \item \textbf{Speed}: Cipher-based (ChaCha20, AES-CTR) $>>$ Hash-based (HMAC)
        \item \textbf{Standards Compliance}: AES-CTR and HMAC-DRBG are NIST-approved
        \item \textbf{Hardware Acceleration}: AES benefits from AES-NI; ChaCha20 is optimized for software
        \item \textbf{Forward Security}: HMAC-DRBG provides explicit state update mechanisms
    \end{itemize}
\end{enumerate}

\subsection{Recommendations}

Based on the experimental results:

\begin{itemize}
    \item \textbf{For general-purpose applications}: ChaCha20-DRBG offers excellent performance without hardware dependencies, making it suitable for diverse platforms
    
    \item \textbf{For NIST compliance requirements}: Use AES-CTR DRBG (with AES-NI) or HMAC-DRBG depending on available primitives
    
    \item \textbf{For resource-constrained environments}: ChaCha20-DRBG provides the best speed/memory trade-off
    
    \item \textbf{For maximum security assurance}: HMAC-DRBG with proper reseeding, despite performance cost, offers robust forward security and is well-analyzed
    
    \item \textbf{For high-throughput scenarios}: AES-CTR on hardware with AES-NI support, or ChaCha20 on platforms without it
\end{itemize}

\appendix

\section{Complete Source Code}

The complete implementation of all three DRBGs and the benchmark suite is provided below. The code is also available in the file \texttt{drbg\_benchmark.py}.

\begin{lstlisting}[style=pythonstyle, caption={ChaCha20-DRBG Implementation}]
from cryptography.hazmat.primitives.ciphers import Cipher, algorithms
from cryptography.hazmat.backends import default_backend
import os

class ChaCha20DRBG:
    """ChaCha20-based Deterministic Random Bit Generator"""
    
    def __init__(self, seed=None):
        if seed is None:
            seed = os.urandom(32)
        elif len(seed) < 32:
            seed = seed.ljust(32, b'\x00')
        
        self.key = seed[:32]
        self.nonce = os.urandom(16)
    
    def generate(self, num_bits: int) -> str:
        num_bytes = (num_bits + 7) // 8
        cipher = Cipher(algorithms.ChaCha20(self.key, self.nonce),
                       mode=None, backend=default_backend())
        encryptor = cipher.encryptor()
        plaintext = b'\x00' * num_bytes
        random_bytes = encryptor.update(plaintext)
        binary_string = ''.join(format(byte, '08b') 
                                for byte in random_bytes)
        return binary_string[:num_bits]
\end{lstlisting}

\begin{lstlisting}[style=pythonstyle, caption={AES-CTR DRBG Implementation}]
from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
from cryptography.hazmat.backends import default_backend
import os

class AESCTR_DRBG:
    """AES-CTR based Deterministic Random Bit Generator"""
    
    def __init__(self, seed=None):
        if seed is None:
            seed = os.urandom(32)
        elif len(seed) < 32:
            seed = seed.ljust(32, b'\x00')
        
        self.key = seed[:32]
        self.counter = 0
    
    def generate(self, num_bits: int) -> str:
        num_bytes = (num_bits + 7) // 8
        nonce = self.counter.to_bytes(16, 'big')
        cipher = Cipher(algorithms.AES(self.key), modes.CTR(nonce),
                       backend=default_backend())
        encryptor = cipher.encryptor()
        plaintext = b'\x00' * num_bytes
        random_bytes = encryptor.update(plaintext) + encryptor.finalize()
        self.counter += 1
        binary_string = ''.join(format(byte, '08b') 
                                for byte in random_bytes)
        return binary_string[:num_bits]
\end{lstlisting}

\begin{lstlisting}[style=pythonstyle, caption={HMAC-DRBG Implementation}]
import hmac
import hashlib
import os

class HMAC_DRBG:
    """HMAC-based DRBG (NIST SP 800-90A)"""
    
    def __init__(self, seed=None):
        if seed is None:
            seed = os.urandom(32)
        self.K = b'\x00' * 32
        self.V = b'\x01' * 32
        self._update(seed)
    
    def _update(self, provided_data=None):
        self.K = hmac.new(self.K, self.V + b'\x00' + 
                         (provided_data if provided_data else b''),
                         hashlib.sha256).digest()
        self.V = hmac.new(self.K, self.V, hashlib.sha256).digest()
        if provided_data is not None:
            self.K = hmac.new(self.K, self.V + b'\x01' + provided_data,
                             hashlib.sha256).digest()
            self.V = hmac.new(self.K, self.V, hashlib.sha256).digest()
    
    def generate(self, num_bits: int) -> str:
        num_bytes = (num_bits + 7) // 8
        output = b''
        while len(output) < num_bytes:
            self.V = hmac.new(self.K, self.V, hashlib.sha256).digest()
            output += self.V
        self._update()
        binary_string = ''.join(format(byte, '08b') 
                                for byte in output)
        return binary_string[:num_bits]
\end{lstlisting}

\end{document}